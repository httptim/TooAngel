'use strict';

/* global RoomPosition FIND_DROPPED_RESOURCES RESOURCE_ENERGY
FIND_CONSTRUCTION_SITES STRUCTURE_CONTAINER */

const Role = require('./role');

const ExploitHarvesterRole = function () {
	Role.call(this);

	// Harvesting energy is essential and doesn't need tons of CPU.
	this.stopAt = 0;
	this.throttleAt = 5000;
};

ExploitHarvesterRole.prototype = Object.create(Role.prototype);

/**
 * Makes a creep behave like an exploit harvester.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 */
ExploitHarvesterRole.prototype.run = function (creep) {
	if (!creep.memory.harvesting && _.sum(creep.carry) <= 0) {
		this.setHarvesterState(creep, true);
	}
	else if (creep.memory.harvesting && _.sum(creep.carry) >= creep.carryCapacity) {
		this.setHarvesterState(creep, false);
	}

	if (this.travelToExploitRoom(creep)) return;

	if (this.repairNearbyExploitContainer(creep)) return;

	if (creep.memory.harvesting) {
		this.performExploitHarvest(creep);
		return;
	}

	this.performExploitHarvesterDeliver(creep);
};

/**
 * Puts a creep into or out of harvesting mode.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 * @param {boolean} harvesting
 *   Whether or not this creep should be harvesting.
 */
ExploitHarvesterRole.prototype.setHarvesterState = function (creep, harvesting) {
	creep.memory.harvesting = harvesting;
	delete creep.memory.resourceTarget;
};

/**
 * Moves a creep to its exploit destination.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 *
 * @return {boolean}
 *   Whether or not the creep is still busy traveling.
 */
ExploitHarvesterRole.prototype.travelToExploitRoom = function (creep) {
	const exploit = Game.exploits[creep.memory.exploitName];
	if (!exploit) return false;

	// Follow cached path when requested.
	if (!creep.hasCachedPath() && creep.pos.roomName !== exploit.roomName && exploit.memory.pathToRoom) {
		creep.setCachedPath(exploit.memory.pathToRoom, false, 3);
		creep.memory.travellingToRoom = true;
		return true;
	}

	creep.followCachedPath();
	if (!creep.hasArrived()) return true;

	creep.clearCachedPath();
	if (!creep.memory.travellingToRoom) return false;

	// Next, travel to destined source.
	const closest = exploit.memory.closestLairToEntrance;
	const source = Game.getObjectById(creep.memory.fixedSource);
	if (closest && source && exploit.memory.lairs[closest]) {
		const lair = source.getNearbyLair();
		if (lair) {
			const target = lair.id;
			const path = exploit.memory.lairs[closest].paths[target];
			if (path && path.path) {
				creep.setCachedPath(exploit.memory.lairs[closest].paths[target].path, false, 3);
			}
			else if (path) {
				creep.setCachedPath(exploit.memory.lairs[target].paths[closest].path, true, 3);
			}
		}
	}

	delete creep.memory.travellingToRoom;

	return false;
};

/**
 * Makes sure to keep nearby container repaired.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 *
 * @return {boolean}
 *   Whether an action has been performed or not.
 */
ExploitHarvesterRole.prototype.repairNearbyExploitContainer = function (creep) {
	const source = Game.getObjectById(creep.memory.fixedSource);
	const container = source.getNearbyContainer();

	if (creep.carry.energy > 0) {
		if (!container) {
			// If a construction site for a container is nearby, help build it to recover.
			const sites = creep.pos.findInRange(FIND_CONSTRUCTION_SITES, 3, {
				filter: site => site.structureType === STRUCTURE_CONTAINER,
			});
			if (sites.length > 0 && creep.carry.energy >= (creep.memory.body.work || 0) * 5) {
				creep.build(sites[0]);
				return true;
			}
		}
		else if (container.hits < container.hitsMax * 0.2 && !source.isDangerous() && creep.carry.energy >= (creep.memory.body.work || 0)) {
			if (creep.pos.getRangeTo(container) > 3) {
				creep.moveTo(container);
			}
			else {
				creep.repair(container);
			}

			return true;
		}
	}

	return false;
};

/**
 * Makes the creep gather resources in the current room.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 */
ExploitHarvesterRole.prototype.performExploitHarvest = function (creep) {
	const source = Game.getObjectById(creep.memory.fixedSource);
	const container = source.getNearbyContainer();

	if (source.isDangerous()) {
		const safeSpot = new RoomPosition(25, 25, creep.room.name);
		if (creep.pos.getRangeTo(safeSpot) > 5) {
			creep.moveToRange(safeSpot, 5);
		}

		return;
	}

	if (!container || _.sum(container.store) < container.storeCapacity) {
		// Pick up nearby resources and put in container.
		const dropped = creep.pos.findInRange(FIND_DROPPED_RESOURCES, 5, {
			filter: resources => container || resources.resourceType === RESOURCE_ENERGY,
		});
		if (dropped.length > 0) {
			if (creep.pos.getRangeTo(dropped[0]) > 1) {
				creep.moveToRange(dropped[0], 1);
			}
			else {
				creep.pickup(dropped[0]);
			}

			return;
		}
	}

	if (creep.pos.getRangeTo(source) > 1) {
		creep.moveTo(source);
	}
	else {
		creep.harvest(source);
	}

	// If there's a container nearby, directly deposit energy.
	if (_.sum(creep.carry) > creep.carryCapacity * 0.5) {
		if (container && creep.pos.getRangeTo(container) <= 1) {
			for (const resourceType in creep.carry) {
				if (creep.carry[resourceType] <= 0) continue;
				creep.transfer(container, resourceType);
				break;
			}
		}
	}
};

/**
 * Dumps minerals a harvester creep has gathered.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 */
ExploitHarvesterRole.prototype.performExploitHarvesterDeliver = function (creep) {
	const source = Game.getObjectById(creep.memory.fixedSource);
	const container = source.getNearbyContainer();

	// By default, deliver to nearby container if there's space.
	// @todo Deliver anything, not just what the source provides.
	if (container && _.sum(container.store) < container.storeCapacity) {
		if (creep.pos.getRangeTo(container) > 1) {
			creep.moveTo(container);
		}
		else {
			for (const resourceType in creep.carry) {
				if (creep.carry[resourceType] <= 0) continue;
				creep.transfer(container, resourceType);
				break;
			}
		}
	}
	else {
		// Just drop it. Somebody will pick it up. Maybe.
		creep.drop(source.mineralType || RESOURCE_ENERGY);
	}
};

module.exports = ExploitHarvesterRole;
